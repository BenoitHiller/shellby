#!/bin/bash

source "$botLib/utility.sh"

# WARNING: disabling globbing. This is probably a good idea almost everywhere.
set -f 

####################
# Helper Functions #
####################

# Filter log files for those between the specified dates
#
# Consumes a list of null separated files from stdin.
# Outputs the filtered list to stdout.
# 1.firstYear
# 2.firstMonth
# 3.firstDay
# 4.lastYear
# 5.lastMonth
# 6.lastDay
filterDateRange() {
  local -r firstYear="$1"
  local -r firstMonth="$2"
  local -r firstDay="$3"
  local -r lastYear="$4"
  local -r lastMonth="$5"
  local -r lastDay="$6"


  gawk -F "/" '
    BEGIN {
      RS = "\0"
      ORS = "\0"
    }

    {
      min = int(sprintf("%d%02d%02d", firstYear, firstMonth, firstDay))
      max = int(sprintf("%d%02d%02d", lastYear, lastMonth, lastDay))
      year = int($(NF - 2))
      month = int(gensub(/^0*/, "", 1, $(NF - 1)))
      day = int(gensub(/_message|^0*/, "", "g", $NF)) 
      summed = int(sprintf("%d%02d%02d", year, month, day))
      if (summed >= min && summed <= max)
      {
        print $0
      }
    }
  ' firstYear="$firstYear" firstMonth="$firstMonth" firstDay="$firstDay" \
    lastYear="$lastYear" lastMonth="$lastMonth" lastDay="$lastDay"
}

# Formats lines in standard IRC log style
#
# Consumes lines of shellby log format from stdin.
# Outputs formatted lines to stdout.
formatLogLines() {
  gawk -F "\r" '
    /^[0-9]+/{
      if ($5 ~ /message/) {
        print "[" strftime("%Y-%m-%d %H:%M:%S",$1) "]", $2 ":", $6
      } else if ( $5 ~ /notice/) {
        print "[" strftime("%Y-%m-%d %H:%M:%S",$1) "] (notice)", $2 ":", $6
      } else if ( $5 ~ /action/) {
        print "[" strftime("%Y-%m-%d %H:%M:%S",$1) "]", "*", $2, $6
      } else {
        print $0
      }
    }
    /^[^0-9]/{print $0}
  '
}

# Parses the -t and -T time parameters
#
# The output is three space separated values:
# year month day
#
# 1.parameterInput the parameter we are parsing
# 2.timeParts[0] the default year
# 2.timeParts[1] the default month
# 2.timeParts[2] the default day
parseTime() {
  local -r parameterInput="$1"
  shift
  local -a timeParts=("$@")

  local -a splitParams=( $(IFS="-"; echo $parameterInput) )
  if [[ "${splitParams[0]}" != "*" ]]; then
    if [[ "${splitParams[0]}" =~ ^[0-9]{2}$ ]]; then
      timeParts[0]="20${splitParams[0]}"
    else
      timeParts[0]="${splitParams[0]##0}"
    fi
  fi
  if [[ "${splitParams[1]}" != "*" ]]; then
      timeParts[1]="${splitParams[1]##0}"
  fi
  if [[ "${splitParams[2]}" != "*" ]]; then
      timeParts[2]="${splitParams[2]##0}"
  fi

  echo "${timeParts[@]}"

}

main() {
  ###################
  # Input Arguments #
  ###################

  local -r channel="$2"
  local -r message="$6"
  local -r fullMessage="$7"

  ##################
  # Variable Setup #
  ##################

  local -a assignableParameters=( m e f A B C t T )
  local -a passThroughFlags=( c i E P F )

  local targetChannel

  local -a splitArgs=()
  local -i i=0

  resplitAndParse "$message"

  if ((${#vargs[@]} > 0)); then

    ###########################
    # Process Time parameters #
    ###########################

    local -a startTime=(0 0 0)
    local -a endTime=(9999 99 99)

    local -r timeRegex="([0-9]{1,4}|\*)-([0-9]{1,2}|\*)-([0-9]{1,2}|\*)"
    

    if [[ "${argMap[t]+_}" && "${argMap[t]}" =~ $timeRegex ]]; then
      startTime=( $(parseTime "${argMap[t]}" "${startTime[@]}") )
    fi

    if [[ "${argMap[T]+_}" && "${argMap[T]}" =~ $timeRegex ]]; then
      endTime=( $(parseTime "${argMap[T]}" "${endTime[@]}") )
    fi

    ############################
    # Process other parameters #
    ############################

    local gargs="$(printf "%s " "${vargs[@]}" | sed 's/ $//;s/\\r/\r/g')"

    local -a gflags=( )

    local re='^[0-9]+$'

    for f in "${passThroughFlags[@]}"; do
      if [[ "${argMap[$f]+_}" ]]; then
        gflags+=( -$f )
      fi
    done

    if [[ "${argMap[C]+_}" && "${argMap[C]}" =~ $re ]]; then
      gflags+=( -C "${argMap[C]}" )
    else 
      if [[ "${argMap[B]+_}" && "${argMap[B]}" =~ $re ]]; then
        gflags+=( -A "${argMap[B]}" )
      fi
      if [[ "${argMap[A]+_}" && "${argMap[A]}" =~ $re ]]; then
        gflags+=( -B "${argMap[A]}" )
      fi
    fi

    if [[ "${argMap[m]+_}" && "${argMap[m]}" =~ $re ]]; then
      gflags+=( -m "${argMap[m]}" )
    fi

    local -r channelRegex="^#[^/]+$"

    if [[ "${argMap[f]+_}" && "${argMap[f]}" =~ $channelRegex ]]; then
      targetChannel="${argMap[f]}"
    else
      targetChannel="$channel"
    fi

    local -ir extendedRegex="${argMap[E]+1}"
    local -ir perlRegex="${argMap[P]+1}"
    local -ir fixedMatch="${argMap[F]+1}"

    if ((extendedRegex + perlRegex + fixedMatch > 1)); then
      privmsg "$channel" "Um, that is more than one regex engine at once. Want to try again?"
      exit 0
    fi

    if [[ ! "$targetChannel" =~ $channelRegex ]]; then
      exit 0
    fi

    ###################
    # Search pipeline #
    ###################

    local -ra emptyMessages=(
      "nada"
      "No one has ever said anything remotely like that."
      "RTFM"
      "Error: your query was dumb"
    )

    local -ri selection="$((RANDOM % ${#emptyMessages[@]}))"

    find "$botLogs/$targetChannel" -type f -name '*_message' -print0 \
      | filterDateRange "${startTime[@]}" "${endTime[@]}" \
      | sort -rz \
      | xargs -0 tac \
      | grep -vF "$fullMessage" \
      | grep "${gflags[@]}" -- "$gargs" \
      | formatLogLines \
      | head -n 500 \
      | tac \
      | ifEmpty "${emptyMessages[$selection]}" \
      | privorpaste "$channel"
  fi
}

main "$@"

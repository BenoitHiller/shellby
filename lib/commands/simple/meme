#!/bin/bash
set -f

source "$botLib/utility.sh"

# Checks the local meme file for a query
#
# 1.query the query string
checkMemeFile() {
  local -r query="$1"
  if [[ ! -e "$memeFile" ]]; then
    return 2
  fi

  grep -E -m 1 "(^$filteredMemeString[,:])|(,\s?$filteredMemeString[,:])" "$memeFile" \
    | sed -E 's/[^:]*:\s?(.*)/\1/'
}

# Gets the first image result on knowyourmeme.com
#
# Chooses randomly whether to sort by views or relevance.
# Neither option is right consistently enough.
#
# 1.query the query string
checkKnowYourMeme() {
  local -r query="$1"
  local -ar sortTypes=( views relevance ) 
  local -r sortType="${sortTypes[$(($RANDOM % 2))]}"

  curl -s -G --data "context=images&sort=$sortType" --data-urlencode "q=$query" http://knowyourmeme.com/search/ \
    | sed -nE "
      /<div class='item/{
        # grab just the line two after the match
        N;g;N

        # extract the src url
        s/.*\ssrc=\"(\S+)\".*/\1/

        # if the link is a NSFW cover, move on to the next match
        /image-covers/{
          d
        }

        # otherwise replace the thumbnail with the full image
        s/masonry/newsfeed/

        # output and exit
        p;q
      }"
}

main() {
  local -r channel="$2"
  local -r message="$6"
  local -r memeFile="$botConfig/memes"

  local -r filteredMemeString="$(tr A-Z a-z <<< "$message" | sed -E 's/[^a-z0-9 ]//;s/^\s+//')"

  if [[ -n "$message" ]]; then
    local result="$(checkMemeFile "$message")"

    if [[ -z "$result" ]]; then
      result="$(checkKnowYourMeme "$message")"
    fi 

    if [[ -z "$result" ]]; then
        privmsg "$channel" "Not cool enough to be a meme."
    else
      echo "$result" | privmsg "$channel"
    fi 

  else
    if [[ ! -e "$memeFile" ]]; then
      exit 2
    fi

    shuf -n 1 "$memeFile" \
      | sed -E 's/[^:]*:\s?(.*)/\1/' \
      | privmsg "$channel"
  fi
}

main "$@"

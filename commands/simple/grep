#!/bin/bash

source "$botDir/lib/utility.sh"

# WARNING: disabling globbing. This is probably a good idea almost everywhere.
set -f 

###################
# Input Arguments #
###################

declare -r channel="$2"
declare -r message="${6#*grep }"
declare -r fullMessage="$6"

####################
# Helper Functions #
####################

# Filter log files for those between the specified dates
#
# Consumes a list of null separated files from stdin.
# Outputs the filtered list to stdout.
# 1.firstYear
# 2.firstMonth
# 3.firstDay
# 4.lastYear
# 5.lastMonth
# 6.lastDay
filterDateRange() {
  local -r firstYear="$1"
  local -r firstMonth="$2"
  local -r firstDay="$3"
  local -r lastYear="$4"
  local -r lastMonth="$5"
  local -r lastDay="$6"


  gawk -F "/" '
    BEGIN {
      RS = "\0"
      ORS = "\0"
    }

    {
      min = int(sprintf("%d%02d%02d", firstYear, firstMonth, firstDay))
      max = int(sprintf("%d%02d%02d", lastYear, lastMonth, lastDay))
      year = int($(NF - 2))
      month = int(gensub(/^0*/, "", 1, $(NF - 1)))
      day = int(gensub(/_message|^0*/, "", "g", $NF)) 
      summed = int(sprintf("%d%02d%02d", year, month, day))
      if (summed >= min && summed <= max)
      {
        print $0
      }
    }
  ' firstYear="$firstYear" firstMonth="$firstMonth" firstDay="$firstDay" \
    lastYear="$lastYear" lastMonth="$lastMonth" lastDay="$lastDay"
}

# Formats lines in standard IRC log style
#
# Consumes lines of shellby log format from stdin.
# Outputs formatted lines to stdout.
formatLogLines() {
  gawk -F "\r" '
    /^[0-9]+/{
      if ($5 ~ "message") {
        print "[" strftime("%Y-%m-%d %H:%M:%S",$1) "]", $2 ":", $6
      }
      else if ( $5 ~ "action") {
        print "[" strftime("%Y-%m-%d %H:%M:%S",$1) "]", "*", $2, $6
      }
      else {
        print $0
      }
    }
    /^[^0-9]/{print $0}
  '
}

# Parses the -t and -T time parameters
#
# The output is three space separated values:
# year month day
#
# 1.parameterInput the parameter we are parsing
# 2.timeParts[0] the default year
# 2.timeParts[1] the default month
# 2.timeParts[2] the default day
parseTime() {
  local -r parameterInput="$1"
  shift
  local -a timeParts=("$@")

  local -a splitParams=( $(IFS="-"; echo $parameterInput) )
  if [[ "${splitParams[0]}" != "*" ]]; then
    if [[ "${splitParams[0]}" =~ ^[0-9]{2}$ ]]; then
      timeParts[0]="20${splitParams[0]}"
    else
      timeParts[0]="${splitParams[0]##0}"
    fi
  fi
  if [[ "${splitParams[1]}" != "*" ]]; then
      timeParts[1]="${splitParams[1]##0}"
  fi
  if [[ "${splitParams[2]}" != "*" ]]; then
      timeParts[2]="${splitParams[2]##0}"
  fi

  echo "${timeParts[@]}"

}

##################
# Variable Setup #
##################

declare -a assignableParameters=( m e f A B C t T )
declare -a passThroughFlags=( c i E P F )

declare targetChannel

declare -a splitArgs=()
declare -i i=0

resplitAndParse "$message"

if (( "${#vargs[@]}" > 0 )); then

  ###########################
  # Process Time parameters #
  ###########################

  declare -a startTime=(0 0 0)
  declare -a endTime=(9999 99 99)

  declare -r timeRegex="([0-9]{1,4}|\*)-([0-9]{1,2}|\*)-([0-9]{1,2}|\*)"
  

  if [[ "${argMap[t]+_}" && "${argMap[t]}" =~ $timeRegex ]]; then
    startTime=( $(parseTime "${argMap[t]}" "${startTime[@]}") )
  fi

  if [[ "${argMap[T]+_}" && "${argMap[T]}" =~ $timeRegex ]]; then
    endTime=( $(parseTime "${argMap[T]}" "${endTime[@]}") )
  fi

  ############################
  # Process other parameters #
  ############################

  declare gargs="$( printf "%s " "${vargs[@]}" | sed 's/ $//')"

  declare -a gflags=( )

  declare re='^[0-9]+$'

  for f in "${passThroughFlags[@]}"; do
    if [[ "${argMap[$f]+_}" ]]; then
      gflags+=( -$f )
    fi
  done

  if [[ "${argMap[C]+_}" && "${argMap[C]}" =~ $re ]]; then
    gflags+=( -C "${argMap[C]}" )
  else 
    if [[ "${argMap[B]+_}" && "${argMap[B]}" =~ $re ]]; then
      gflags+=( -A "${argMap[B]}" )
    fi
    if [[ "${argMap[A]+_}" && "${argMap[A]}" =~ $re ]]; then
      gflags+=( -B "${argMap[A]}" )
    fi
  fi

  if [[ "${argMap[m]+_}" && "${argMap[m]}" =~ $re ]]; then
    gflags+=( -m "${argMap[m]}" )
  fi

  declare -r channelRegex="^#[^/]+$"

  if [[ "${argMap[f]+_}" && "${argMap[f]}" =~ $channelRegex ]]; then
    targetChannel="${argMap[f]}"
  else
    targetChannel="$channel"
  fi

  declare -ir extendedRegex="${argMap[E]+1}"
  declare -ir perlRegex="${argMap[P]+1}"
  declare -ir fixedMatch="${argMap[F]+1}"

  if (( extendedRegex + perlRegex + fixedMatch > 1 )); then
    privmsg "$channel" "conflicting options selected"
    exit 0
  fi

  if [[ ! "$targetChannel" =~ $channelRegex ]]; then
    exit 0
  fi

  ###################
  # Search pipeline #
  ###################

  find "$botDir/logs/$targetChannel" -type f -name '*_message' -print0 \
    | filterDateRange "${startTime[@]}" "${endTime[@]}" \
    | sort -rz \
    | xargs -0 tac \
    | grep -vF "$fullMessage" \
    | grep "${gflags[@]}" -- "$gargs" \
    | formatLogLines \
    | head -n 500 \
    | tac \
    | privorpaste "$channel"
fi
